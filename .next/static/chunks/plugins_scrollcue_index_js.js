"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["plugins_scrollcue_index_js"],{

/***/ "./plugins/scrollcue/index.js":
/*!************************************!*\
  !*** ./plugins/scrollcue/index.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**-----------------------\n\n scrollCue.js - ver.2.0.0\n URL : https://prjct-samwest.github.io/scrollCue/\n\n created by SamWest.\n Copyright (c) 2020 SamWest.\n This plugin is released under the MIT License.\n\n -----------------------**/ const scrollCue = function() {\n    let $f = {}, $e, $q;\n    let resizeTimer = 0, scrollEnable = true, enable = true, ds = false, pcr = false;\n    let $op, $defaultOptions = {\n        duration: 600,\n        interval: -0.7,\n        percentage: 0.75,\n        enable: true,\n        docSlider: false,\n        pageChangeReset: false\n    };\n    $f = {\n        setEvents: function(startHash) {\n            let scroll = function() {\n                if (scrollEnable) {\n                    requestAnimationFrame(function() {\n                        scrollEnable = true;\n                        if (enable) {\n                            $f.setQuery();\n                            $f.runQuery();\n                        }\n                    });\n                    scrollEnable = false;\n                }\n            };\n            if (enable && !startHash) {\n                window.addEventListener(\"load\", $f.runQuery);\n            }\n            window.addEventListener(\"scroll\", scroll);\n            if (ds) {\n                let pages = docSlider.getElements().pages;\n                for(let i = 0; i < pages.length; i++){\n                    let page = pages[i];\n                    page.addEventListener(\"scroll\", function(e) {\n                        let c = docSlider.getCurrentIndex() + \"\";\n                        let i = e.target.getAttribute(\"data-ds-index\");\n                        if (c !== i) return false;\n                        if (docSlider._getWheelEnable()) scroll();\n                    });\n                }\n            }\n            window.addEventListener(\"resize\", function() {\n                if (resizeTimer > 0) {\n                    clearTimeout(resizeTimer);\n                }\n                resizeTimer = setTimeout(function() {\n                    if (enable) {\n                        $f.searchElements();\n                        $f.setQuery();\n                        $f.runQuery();\n                    }\n                }, 200);\n            });\n        },\n        setOptions: function(tgt, add) {\n            let resultOptions = {};\n            if (typeof tgt === \"undefined\") return;\n            Object.keys(tgt).forEach(function(key) {\n                if (Object.prototype.toString.call(tgt[key]) === \"[object Object]\") {\n                    resultOptions[key] = $f.setOptions(tgt[key], add[key]);\n                } else {\n                    resultOptions[key] = tgt[key];\n                    if (typeof add !== \"undefined\" && typeof add[key] !== \"undefined\") {\n                        resultOptions[key] = add[key];\n                    }\n                }\n            });\n            return resultOptions;\n        },\n        searchElements: function() {\n            let parents, selector;\n            $e = [];\n            parents = document.querySelectorAll(\"[data-cues]:not([data-disabled])\");\n            for(let i = 0; i < parents.length; i++){\n                let parent = parents[i];\n                for(let j = 0; j < parent.children.length; j++){\n                    let child = parent.children[j];\n                    $f.setAttrPtoC(child, \"data-cue\", parent, \"data-cues\", \"\");\n                    $f.setAttrPtoC(child, \"data-duration\", parent, \"data-duration\", false);\n                    $f.setAttrPtoC(child, \"data-interval\", parent, \"data-interval\", false);\n                    $f.setAttrPtoC(child, \"data-sort\", parent, \"data-sort\", false);\n                    $f.setAttrPtoC(child, \"data-addClass\", parent, \"data-addClass\", false);\n                    $f.setAttrPtoC(child, \"data-group\", parent, \"data-group\", false);\n                    $f.setAttrPtoC(child, \"data-delay\", parent, \"data-delay\", false);\n                }\n                parent.setAttribute(\"data-disabled\", \"true\");\n            }\n            selector = document.querySelectorAll('[data-cue]:not([data-show=\"true\"])');\n            for(let i = 0; i < selector.length; i++){\n                let elm = selector[i];\n                $e.push({\n                    elm: elm,\n                    cue: $f.getAttr(elm, \"data-cue\", \"fadeIn\"),\n                    duration: Number($f.getAttr(elm, \"data-duration\", $op.duration)),\n                    interval: Number($f.getAttr(elm, \"data-interval\", $op.interval)),\n                    order: $f.getOrderNumber(elm),\n                    sort: $f.getAttr(elm, \"data-sort\", null),\n                    addClass: $f.getAttr(elm, \"data-addClass\", null),\n                    group: $f.getAttr(elm, \"data-group\", null),\n                    delay: Number($f.getAttr(elm, \"data-delay\", 0))\n                });\n            }\n            if (ds) {\n                let pages = docSlider.getElements().pages.length;\n                for(let i = 0; i < pages; i++){\n                    let elms = document.querySelectorAll('[data-ds-index=\"' + i + '\"] [data-cue]:not([data-scpage])');\n                    for(let j = 0; j < elms.length; j++){\n                        elms[j].setAttribute(\"data-scpage\", i);\n                    }\n                }\n            }\n        },\n        sortElements: function() {\n            let obj = arguments[0];\n            let keys = [].slice.call(arguments).slice(1);\n            for(let i = 0; i < keys.length; i++){\n                obj.sort(function(a, b) {\n                    let asc = typeof keys[i][1] === \"undefined\" ? true : keys[i][1];\n                    let key = keys[i][0];\n                    if (a[key] > b[key]) return asc ? 1 : -1;\n                    if (a[key] < b[key]) return asc ? -1 : 1;\n                    return 0;\n                });\n            }\n        },\n        randElements: function(array) {\n            for(let i = array.length - 1; i > 0; i--){\n                let j = Math.floor(Math.random() * (i + 1));\n                let tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n            }\n            return array;\n        },\n        setDurationValue: function(interval, pElm, cInt) {\n            if (typeof pElm === \"undefined\") {\n                return interval;\n            }\n            let result = interval;\n            let pDura = pElm.duration;\n            if (!((cInt + \"\").indexOf(\".\") !== -1)) {\n                result = result + pDura + cInt;\n            } else {\n                result = result + pDura + pDura * cInt;\n            }\n            result = result < 0 ? 0 : result;\n            return result;\n        },\n        getOrderNumber: function(elm) {\n            if (elm.hasAttribute(\"data-order\")) {\n                let num = Number(elm.getAttribute(\"data-order\"));\n                return num >= 0 ? num : Math.pow(2, 53) - 1 + num;\n            } else {\n                return Math.pow(2, 52) - 1;\n            }\n        },\n        setAttrPtoC: function(child, attrC, parent, attrP, value) {\n            if (parent.hasAttribute(attrP)) {\n                if (!child.hasAttribute(attrC)) {\n                    child.setAttribute(attrC, parent.getAttribute(attrP));\n                }\n            } else {\n                if (value !== false) {\n                    child.setAttribute(attrC, value);\n                }\n            }\n        },\n        getAttr: function(elm, attr, value) {\n            if (elm.hasAttribute(attr)) {\n                return elm.getAttribute(attr);\n            } else {\n                return value;\n            }\n        },\n        getOffsetTop: function(elm) {\n            let rect = elm.getBoundingClientRect();\n            let scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n            return rect.top + scrollTop; // offset().top;\n        },\n        setClassNames: function(elm, classNames) {\n            if (!classNames) {\n                return;\n            }\n            let classNamesArr = classNames.split(\" \");\n            for(let i = 0; i < classNamesArr.length; i++){\n                elm.classList.add(classNamesArr[i]);\n            }\n        },\n        setQuery: function() {\n            $q = {};\n            for(let i = 0; i < $e.length; i++){\n                let elm = $e[i];\n                let group = elm.group ? elm.group : \"$\" + $f.getOffsetTop(elm.elm);\n                if (elm.elm.hasAttribute(\"data-show\")) {\n                    continue;\n                }\n                if (ds) {\n                    let iIndex = elm.elm.getAttribute(\"data-scpage\");\n                    let cIndex = docSlider.getCurrentIndex() + \"\";\n                    if (iIndex !== cIndex && !(iIndex === null)) {\n                        continue;\n                    }\n                }\n                if (typeof $q[group] === \"undefined\") {\n                    $q[group] = [];\n                }\n                $q[group].push(elm);\n            }\n        },\n        runQuery: function() {\n            let groups = Object.keys($q);\n            for(let i = 0; i < groups.length; i++){\n                let elms = $q[groups[i]];\n                if ($f.isElementIn(elms[0].elm)) {\n                    if (elms[0].sort === \"reverse\") {\n                        elms.reverse();\n                    } else if (elms[0].sort === \"random\") {\n                        $f.randElements(elms);\n                    }\n                    $f.sortElements(elms, [\n                        \"order\"\n                    ]);\n                    let interval = 0;\n                    for(let j = 0; j < elms.length; j++){\n                        (function(j) {\n                            elms[j].elm.setAttribute(\"data-show\", \"true\");\n                            $f.setClassNames(elms[j].elm, elms[j].addClass);\n                            interval = $f.setDurationValue(interval, elms[j - 1], elms[j].interval);\n                            elms[j].elm.style.animationName = elms[j].cue;\n                            elms[j].elm.style.animationDuration = elms[j].duration + \"ms\";\n                            elms[j].elm.style.animationTimingFunction = \"ease\";\n                            elms[j].elm.style.animationDelay = interval + elms[j].delay + \"ms\";\n                            elms[j].elm.style.animationDirection = \"normal\";\n                            elms[j].elm.style.animationFillMode = \"both\";\n                        })(j);\n                    }\n                    delete $q[groups[i]];\n                }\n            }\n        },\n        isElementIn: function(elm) {\n            let scrollEndJudge = elm.hasAttribute(\"data-scpage\") ? $f.isScrollEndWithDocSlider : $f.isScrollEnd;\n            return window.pageYOffset > $f.getOffsetTop(elm) - window.innerHeight * $op.percentage || scrollEndJudge();\n        },\n        isScrollEnd: function() {\n            let body = window.document.body;\n            let html = window.document.documentElement;\n            let scrollTop = body.scrollTop || html.scrollTop;\n            return scrollTop >= html.scrollHeight - html.clientHeight;\n        },\n        isScrollEndWithDocSlider: function() {\n            let page = docSlider.getCurrentPage();\n            return page.scrollTop >= page.scrollHeight - page.clientHeight;\n        }\n    };\n    return {\n        init: function(options) {\n            $op = $f.setOptions($defaultOptions, options);\n            enable = $op.enable;\n            ds = $op.docSlider;\n            pcr = $op.pageChangeReset;\n            if (ds) {\n                return;\n            }\n            $f.setEvents();\n            $f.searchElements();\n            $f.setQuery();\n        },\n        update: function() {\n            if (enable) {\n                $f.searchElements();\n                $f.setQuery();\n                $f.runQuery();\n            }\n        },\n        enable: function(bool) {\n            enable = typeof bool === \"undefined\" ? !enable : bool;\n            scrollCue.update();\n        },\n        _hasDocSlider: function() {\n            return ds;\n        },\n        _hasPageChangeReset: function() {\n            return pcr;\n        },\n        _initWithDocSlider: function(startHash) {\n            $f.setEvents(startHash);\n            $f.searchElements();\n            $f.setQuery();\n        },\n        _updateWithDocSlider: function() {\n            if (enable) {\n                $f.setQuery();\n                $f.runQuery();\n            }\n        },\n        _searchElements: function() {\n            $f.searchElements();\n        }\n    };\n}();\n/* harmony default export */ __webpack_exports__[\"default\"] = (scrollCue);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztRQUNIO1FBQ0FxSCxpQkFBaUIsV0FBWTtZQUMzQnpJLEdBQUdvQyxjQUFjO1FBQ25CO0lBQ0Y7QUFDRjtBQUVBLCtEQUFlckMsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wbHVnaW5zL3Njcm9sbGN1ZS9pbmRleC5qcz83NDQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiBzY3JvbGxDdWUuanMgLSB2ZXIuMi4wLjBcbiBVUkwgOiBodHRwczovL3ByamN0LXNhbXdlc3QuZ2l0aHViLmlvL3Njcm9sbEN1ZS9cblxuIGNyZWF0ZWQgYnkgU2FtV2VzdC5cbiBDb3B5cmlnaHQgKGMpIDIwMjAgU2FtV2VzdC5cbiBUaGlzIHBsdWdpbiBpcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSoqL1xuXG5jb25zdCBzY3JvbGxDdWUgPSAoZnVuY3Rpb24gKCkge1xuICBsZXQgJGYgPSB7fSxcbiAgICAkZSxcbiAgICAkcTtcbiAgbGV0IHJlc2l6ZVRpbWVyID0gMCxcbiAgICBzY3JvbGxFbmFibGUgPSB0cnVlLFxuICAgIGVuYWJsZSA9IHRydWUsXG4gICAgZHMgPSBmYWxzZSxcbiAgICBwY3IgPSBmYWxzZTtcblxuICBsZXQgJG9wLFxuICAgICRkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGR1cmF0aW9uOiA2MDAsXG4gICAgICBpbnRlcnZhbDogLTAuNyxcbiAgICAgIHBlcmNlbnRhZ2U6IDAuNzUsXG4gICAgICBlbmFibGU6IHRydWUsXG4gICAgICBkb2NTbGlkZXI6IGZhbHNlLFxuICAgICAgcGFnZUNoYW5nZVJlc2V0OiBmYWxzZVxuICAgIH07XG5cbiAgJGYgPSB7XG4gICAgc2V0RXZlbnRzOiBmdW5jdGlvbiAoc3RhcnRIYXNoKSB7XG4gICAgICBsZXQgc2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2Nyb2xsRW5hYmxlKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjcm9sbEVuYWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgICAgICAgJGYuc2V0UXVlcnkoKTtcbiAgICAgICAgICAgICAgJGYucnVuUXVlcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzY3JvbGxFbmFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGVuYWJsZSAmJiAhc3RhcnRIYXNoKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgJGYucnVuUXVlcnkpO1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsKTtcblxuICAgICAgaWYgKGRzKSB7XG4gICAgICAgIGxldCBwYWdlcyA9IGRvY1NsaWRlci5nZXRFbGVtZW50cygpLnBhZ2VzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgcGFnZSA9IHBhZ2VzW2ldO1xuXG4gICAgICAgICAgcGFnZS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgbGV0IGMgPSBkb2NTbGlkZXIuZ2V0Q3VycmVudEluZGV4KCkgKyAnJztcbiAgICAgICAgICAgIGxldCBpID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRzLWluZGV4Jyk7XG5cbiAgICAgICAgICAgIGlmIChjICE9PSBpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChkb2NTbGlkZXIuX2dldFdoZWVsRW5hYmxlKCkpIHNjcm9sbCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXNpemVUaW1lciA+IDApIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGVuYWJsZSkge1xuICAgICAgICAgICAgJGYuc2VhcmNoRWxlbWVudHMoKTtcbiAgICAgICAgICAgICRmLnNldFF1ZXJ5KCk7XG4gICAgICAgICAgICAkZi5ydW5RdWVyeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24gKHRndCwgYWRkKSB7XG4gICAgICBsZXQgcmVzdWx0T3B0aW9ucyA9IHt9O1xuXG4gICAgICBpZiAodHlwZW9mIHRndCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgICAgT2JqZWN0LmtleXModGd0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0Z3Rba2V5XSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgcmVzdWx0T3B0aW9uc1trZXldID0gJGYuc2V0T3B0aW9ucyh0Z3Rba2V5XSwgYWRkW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdE9wdGlvbnNba2V5XSA9IHRndFtrZXldO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBhZGQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhZGRba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdE9wdGlvbnNba2V5XSA9IGFkZFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHRPcHRpb25zO1xuICAgIH0sXG4gICAgc2VhcmNoRWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBwYXJlbnRzLCBzZWxlY3RvcjtcblxuICAgICAgJGUgPSBbXTtcblxuICAgICAgcGFyZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWN1ZXNdOm5vdChbZGF0YS1kaXNhYmxlZF0pJyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcGFyZW50ID0gcGFyZW50c1tpXTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltqXTtcblxuICAgICAgICAgICRmLnNldEF0dHJQdG9DKGNoaWxkLCAnZGF0YS1jdWUnLCBwYXJlbnQsICdkYXRhLWN1ZXMnLCAnJyk7XG4gICAgICAgICAgJGYuc2V0QXR0clB0b0MoY2hpbGQsICdkYXRhLWR1cmF0aW9uJywgcGFyZW50LCAnZGF0YS1kdXJhdGlvbicsIGZhbHNlKTtcbiAgICAgICAgICAkZi5zZXRBdHRyUHRvQyhjaGlsZCwgJ2RhdGEtaW50ZXJ2YWwnLCBwYXJlbnQsICdkYXRhLWludGVydmFsJywgZmFsc2UpO1xuICAgICAgICAgICRmLnNldEF0dHJQdG9DKGNoaWxkLCAnZGF0YS1zb3J0JywgcGFyZW50LCAnZGF0YS1zb3J0JywgZmFsc2UpO1xuICAgICAgICAgICRmLnNldEF0dHJQdG9DKGNoaWxkLCAnZGF0YS1hZGRDbGFzcycsIHBhcmVudCwgJ2RhdGEtYWRkQ2xhc3MnLCBmYWxzZSk7XG4gICAgICAgICAgJGYuc2V0QXR0clB0b0MoY2hpbGQsICdkYXRhLWdyb3VwJywgcGFyZW50LCAnZGF0YS1ncm91cCcsIGZhbHNlKTtcbiAgICAgICAgICAkZi5zZXRBdHRyUHRvQyhjaGlsZCwgJ2RhdGEtZGVsYXknLCBwYXJlbnQsICdkYXRhLWRlbGF5JywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY3VlXTpub3QoW2RhdGEtc2hvdz1cInRydWVcIl0pJyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGVsbSA9IHNlbGVjdG9yW2ldO1xuXG4gICAgICAgICRlLnB1c2goe1xuICAgICAgICAgIGVsbTogZWxtLFxuICAgICAgICAgIGN1ZTogJGYuZ2V0QXR0cihlbG0sICdkYXRhLWN1ZScsICdmYWRlSW4nKSxcbiAgICAgICAgICBkdXJhdGlvbjogTnVtYmVyKCRmLmdldEF0dHIoZWxtLCAnZGF0YS1kdXJhdGlvbicsICRvcC5kdXJhdGlvbikpLFxuICAgICAgICAgIGludGVydmFsOiBOdW1iZXIoJGYuZ2V0QXR0cihlbG0sICdkYXRhLWludGVydmFsJywgJG9wLmludGVydmFsKSksXG4gICAgICAgICAgb3JkZXI6ICRmLmdldE9yZGVyTnVtYmVyKGVsbSksXG4gICAgICAgICAgc29ydDogJGYuZ2V0QXR0cihlbG0sICdkYXRhLXNvcnQnLCBudWxsKSxcbiAgICAgICAgICBhZGRDbGFzczogJGYuZ2V0QXR0cihlbG0sICdkYXRhLWFkZENsYXNzJywgbnVsbCksXG4gICAgICAgICAgZ3JvdXA6ICRmLmdldEF0dHIoZWxtLCAnZGF0YS1ncm91cCcsIG51bGwpLFxuICAgICAgICAgIGRlbGF5OiBOdW1iZXIoJGYuZ2V0QXR0cihlbG0sICdkYXRhLWRlbGF5JywgMCkpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZHMpIHtcbiAgICAgICAgbGV0IHBhZ2VzID0gZG9jU2xpZGVyLmdldEVsZW1lbnRzKCkucGFnZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZXM7IGkrKykge1xuICAgICAgICAgIGxldCBlbG1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZHMtaW5kZXg9XCInICsgaSArICdcIl0gW2RhdGEtY3VlXTpub3QoW2RhdGEtc2NwYWdlXSknKTtcblxuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZWxtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZWxtc1tqXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2NwYWdlJywgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzb3J0RWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgICBsZXQga2V5cyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zbGljZSgxKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9iai5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgbGV0IGFzYyA9IHR5cGVvZiBrZXlzW2ldWzFdID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBrZXlzW2ldWzFdO1xuICAgICAgICAgIGxldCBrZXkgPSBrZXlzW2ldWzBdO1xuXG4gICAgICAgICAgaWYgKGFba2V5XSA+IGJba2V5XSkgcmV0dXJuIGFzYyA/IDEgOiAtMTtcbiAgICAgICAgICBpZiAoYVtrZXldIDwgYltrZXldKSByZXR1cm4gYXNjID8gLTEgOiAxO1xuXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmFuZEVsZW1lbnRzOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgIGxldCB0bXAgPSBhcnJheVtpXTtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgYXJyYXlbal0gPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuICAgIHNldER1cmF0aW9uVmFsdWU6IGZ1bmN0aW9uIChpbnRlcnZhbCwgcEVsbSwgY0ludCkge1xuICAgICAgaWYgKHR5cGVvZiBwRWxtID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSBpbnRlcnZhbDtcbiAgICAgIGxldCBwRHVyYSA9IHBFbG0uZHVyYXRpb247XG5cbiAgICAgIGlmICghKChjSW50ICsgJycpLmluZGV4T2YoJy4nKSAhPT0gLTEpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHBEdXJhICsgY0ludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHBEdXJhICsgcER1cmEgKiBjSW50O1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSByZXN1bHQgPCAwID8gMCA6IHJlc3VsdDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGdldE9yZGVyTnVtYmVyOiBmdW5jdGlvbiAoZWxtKSB7XG4gICAgICBpZiAoZWxtLmhhc0F0dHJpYnV0ZSgnZGF0YS1vcmRlcicpKSB7XG4gICAgICAgIGxldCBudW0gPSBOdW1iZXIoZWxtLmdldEF0dHJpYnV0ZSgnZGF0YS1vcmRlcicpKTtcblxuICAgICAgICByZXR1cm4gbnVtID49IDAgPyBudW0gOiBNYXRoLnBvdygyLCA1MykgLSAxICsgbnVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIDUyKSAtIDE7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBdHRyUHRvQzogZnVuY3Rpb24gKGNoaWxkLCBhdHRyQywgcGFyZW50LCBhdHRyUCwgdmFsdWUpIHtcbiAgICAgIGlmIChwYXJlbnQuaGFzQXR0cmlidXRlKGF0dHJQKSkge1xuICAgICAgICBpZiAoIWNoaWxkLmhhc0F0dHJpYnV0ZShhdHRyQykpIHtcbiAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoYXR0ckMsIHBhcmVudC5nZXRBdHRyaWJ1dGUoYXR0clApKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShhdHRyQywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRBdHRyOiBmdW5jdGlvbiAoZWxtLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVsbS5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgcmV0dXJuIGVsbS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRPZmZzZXRUb3A6IGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgIGxldCByZWN0ID0gZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgbGV0IHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICByZXR1cm4gcmVjdC50b3AgKyBzY3JvbGxUb3A7IC8vIG9mZnNldCgpLnRvcDtcbiAgICB9LFxuICAgIHNldENsYXNzTmFtZXM6IGZ1bmN0aW9uIChlbG0sIGNsYXNzTmFtZXMpIHtcbiAgICAgIGlmICghY2xhc3NOYW1lcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBjbGFzc05hbWVzQXJyID0gY2xhc3NOYW1lcy5zcGxpdCgnICcpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTmFtZXNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lc0FycltpXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRRdWVyeTogZnVuY3Rpb24gKCkge1xuICAgICAgJHEgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAkZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZWxtID0gJGVbaV07XG4gICAgICAgIGxldCBncm91cCA9IGVsbS5ncm91cCA/IGVsbS5ncm91cCA6ICckJyArICRmLmdldE9mZnNldFRvcChlbG0uZWxtKTtcblxuICAgICAgICBpZiAoZWxtLmVsbS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2hvdycpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHMpIHtcbiAgICAgICAgICBsZXQgaUluZGV4ID0gZWxtLmVsbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2NwYWdlJyk7XG4gICAgICAgICAgbGV0IGNJbmRleCA9IGRvY1NsaWRlci5nZXRDdXJyZW50SW5kZXgoKSArICcnO1xuXG4gICAgICAgICAgaWYgKGlJbmRleCAhPT0gY0luZGV4ICYmICEoaUluZGV4ID09PSBudWxsKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAkcVtncm91cF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgJHFbZ3JvdXBdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAkcVtncm91cF0ucHVzaChlbG0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcnVuUXVlcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBncm91cHMgPSBPYmplY3Qua2V5cygkcSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlbG1zID0gJHFbZ3JvdXBzW2ldXTtcblxuICAgICAgICBpZiAoJGYuaXNFbGVtZW50SW4oZWxtc1swXS5lbG0pKSB7XG4gICAgICAgICAgaWYgKGVsbXNbMF0uc29ydCA9PT0gJ3JldmVyc2UnKSB7XG4gICAgICAgICAgICBlbG1zLnJldmVyc2UoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsbXNbMF0uc29ydCA9PT0gJ3JhbmRvbScpIHtcbiAgICAgICAgICAgICRmLnJhbmRFbGVtZW50cyhlbG1zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZi5zb3J0RWxlbWVudHMoZWxtcywgWydvcmRlciddKTtcblxuICAgICAgICAgIGxldCBpbnRlcnZhbCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoaikge1xuICAgICAgICAgICAgICBlbG1zW2pdLmVsbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2hvdycsICd0cnVlJyk7XG5cbiAgICAgICAgICAgICAgJGYuc2V0Q2xhc3NOYW1lcyhlbG1zW2pdLmVsbSwgZWxtc1tqXS5hZGRDbGFzcyk7XG5cbiAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAkZi5zZXREdXJhdGlvblZhbHVlKGludGVydmFsLCBlbG1zW2ogLSAxXSwgZWxtc1tqXS5pbnRlcnZhbCk7XG5cbiAgICAgICAgICAgICAgZWxtc1tqXS5lbG0uc3R5bGUuYW5pbWF0aW9uTmFtZSA9IGVsbXNbal0uY3VlO1xuICAgICAgICAgICAgICBlbG1zW2pdLmVsbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IGVsbXNbal0uZHVyYXRpb24gKyAnbXMnO1xuICAgICAgICAgICAgICBlbG1zW2pdLmVsbS5zdHlsZS5hbmltYXRpb25UaW1pbmdGdW5jdGlvbiA9ICdlYXNlJztcbiAgICAgICAgICAgICAgZWxtc1tqXS5lbG0uc3R5bGUuYW5pbWF0aW9uRGVsYXkgPSBpbnRlcnZhbCArIGVsbXNbal0uZGVsYXkgKyAnbXMnO1xuICAgICAgICAgICAgICBlbG1zW2pdLmVsbS5zdHlsZS5hbmltYXRpb25EaXJlY3Rpb24gPSAnbm9ybWFsJztcbiAgICAgICAgICAgICAgZWxtc1tqXS5lbG0uc3R5bGUuYW5pbWF0aW9uRmlsbE1vZGUgPSAnYm90aCc7XG4gICAgICAgICAgICB9KShqKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGUgJHFbZ3JvdXBzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaXNFbGVtZW50SW46IGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgIGxldCBzY3JvbGxFbmRKdWRnZSA9IGVsbS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2NwYWdlJykgPyAkZi5pc1Njcm9sbEVuZFdpdGhEb2NTbGlkZXIgOiAkZi5pc1Njcm9sbEVuZDtcblxuICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCA+ICRmLmdldE9mZnNldFRvcChlbG0pIC0gd2luZG93LmlubmVySGVpZ2h0ICogJG9wLnBlcmNlbnRhZ2UgfHwgc2Nyb2xsRW5kSnVkZ2UoKTtcbiAgICB9LFxuICAgIGlzU2Nyb2xsRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgYm9keSA9IHdpbmRvdy5kb2N1bWVudC5ib2R5O1xuICAgICAgbGV0IGh0bWwgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgbGV0IHNjcm9sbFRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGh0bWwuc2Nyb2xsVG9wO1xuXG4gICAgICByZXR1cm4gc2Nyb2xsVG9wID49IGh0bWwuc2Nyb2xsSGVpZ2h0IC0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gICAgfSxcbiAgICBpc1Njcm9sbEVuZFdpdGhEb2NTbGlkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBwYWdlID0gZG9jU2xpZGVyLmdldEN1cnJlbnRQYWdlKCk7XG5cbiAgICAgIHJldHVybiBwYWdlLnNjcm9sbFRvcCA+PSBwYWdlLnNjcm9sbEhlaWdodCAtIHBhZ2UuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAkb3AgPSAkZi5zZXRPcHRpb25zKCRkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBlbmFibGUgPSAkb3AuZW5hYmxlO1xuICAgICAgZHMgPSAkb3AuZG9jU2xpZGVyO1xuICAgICAgcGNyID0gJG9wLnBhZ2VDaGFuZ2VSZXNldDtcblxuICAgICAgaWYgKGRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgJGYuc2V0RXZlbnRzKCk7XG4gICAgICAkZi5zZWFyY2hFbGVtZW50cygpO1xuICAgICAgJGYuc2V0UXVlcnkoKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVuYWJsZSkge1xuICAgICAgICAkZi5zZWFyY2hFbGVtZW50cygpO1xuICAgICAgICAkZi5zZXRRdWVyeSgpO1xuICAgICAgICAkZi5ydW5RdWVyeSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgZW5hYmxlID0gdHlwZW9mIGJvb2wgPT09ICd1bmRlZmluZWQnID8gIWVuYWJsZSA6IGJvb2w7XG4gICAgICBzY3JvbGxDdWUudXBkYXRlKCk7XG4gICAgfSxcbiAgICBfaGFzRG9jU2xpZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZHM7XG4gICAgfSxcbiAgICBfaGFzUGFnZUNoYW5nZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGNyO1xuICAgIH0sXG4gICAgX2luaXRXaXRoRG9jU2xpZGVyOiBmdW5jdGlvbiAoc3RhcnRIYXNoKSB7XG4gICAgICAkZi5zZXRFdmVudHMoc3RhcnRIYXNoKTtcbiAgICAgICRmLnNlYXJjaEVsZW1lbnRzKCk7XG4gICAgICAkZi5zZXRRdWVyeSgpO1xuICAgIH0sXG4gICAgX3VwZGF0ZVdpdGhEb2NTbGlkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgJGYuc2V0UXVlcnkoKTtcbiAgICAgICAgJGYucnVuUXVlcnkoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9zZWFyY2hFbGVtZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgJGYuc2VhcmNoRWxlbWVudHMoKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBzY3JvbGxDdWU7XG4iXSwibmFtZXMiOlsic2Nyb2xsQ3VlIiwiJGYiLCIkZSIsIiRxIiwicmVzaXplVGltZXIiLCJzY3JvbGxFbmFibGUiLCJlbmFibGUiLCJkcyIsInBjciIsIiRvcCIsIiRkZWZhdWx0T3B0aW9ucyIsImR1cmF0aW9uIiwiaW50ZXJ2YWwiLCJwZXJjZW50YWdlIiwiZG9jU2xpZGVyIiwicGFnZUNoYW5nZVJlc2V0Iiwic2V0RXZlbnRzIiwic3RhcnRIYXNoIiwic2Nyb2xsIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0UXVlcnkiLCJydW5RdWVyeSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYWdlcyIsImdldEVsZW1lbnRzIiwiaSIsImxlbmd0aCIsInBhZ2UiLCJlIiwiYyIsImdldEN1cnJlbnRJbmRleCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIl9nZXRXaGVlbEVuYWJsZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJzZWFyY2hFbGVtZW50cyIsInNldE9wdGlvbnMiLCJ0Z3QiLCJhZGQiLCJyZXN1bHRPcHRpb25zIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJwYXJlbnRzIiwic2VsZWN0b3IiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJwYXJlbnQiLCJqIiwiY2hpbGRyZW4iLCJjaGlsZCIsInNldEF0dHJQdG9DIiwic2V0QXR0cmlidXRlIiwiZWxtIiwicHVzaCIsImN1ZSIsImdldEF0dHIiLCJOdW1iZXIiLCJvcmRlciIsImdldE9yZGVyTnVtYmVyIiwic29ydCIsImFkZENsYXNzIiwiZ3JvdXAiLCJkZWxheSIsImVsbXMiLCJzb3J0RWxlbWVudHMiLCJvYmoiLCJhcmd1bWVudHMiLCJzbGljZSIsImEiLCJiIiwiYXNjIiwicmFuZEVsZW1lbnRzIiwiYXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0bXAiLCJzZXREdXJhdGlvblZhbHVlIiwicEVsbSIsImNJbnQiLCJyZXN1bHQiLCJwRHVyYSIsImluZGV4T2YiLCJoYXNBdHRyaWJ1dGUiLCJudW0iLCJwb3ciLCJhdHRyQyIsImF0dHJQIiwidmFsdWUiLCJhdHRyIiwiZ2V0T2Zmc2V0VG9wIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiZG9jdW1lbnRFbGVtZW50IiwidG9wIiwic2V0Q2xhc3NOYW1lcyIsImNsYXNzTmFtZXMiLCJjbGFzc05hbWVzQXJyIiwic3BsaXQiLCJjbGFzc0xpc3QiLCJpSW5kZXgiLCJjSW5kZXgiLCJncm91cHMiLCJpc0VsZW1lbnRJbiIsInJldmVyc2UiLCJzdHlsZSIsImFuaW1hdGlvbk5hbWUiLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uIiwiYW5pbWF0aW9uRGVsYXkiLCJhbmltYXRpb25EaXJlY3Rpb24iLCJhbmltYXRpb25GaWxsTW9kZSIsInNjcm9sbEVuZEp1ZGdlIiwiaXNTY3JvbGxFbmRXaXRoRG9jU2xpZGVyIiwiaXNTY3JvbGxFbmQiLCJpbm5lckhlaWdodCIsImJvZHkiLCJodG1sIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0Q3VycmVudFBhZ2UiLCJpbml0Iiwib3B0aW9ucyIsInVwZGF0ZSIsImJvb2wiLCJfaGFzRG9jU2xpZGVyIiwiX2hhc1BhZ2VDaGFuZ2VSZXNldCIsIl9pbml0V2l0aERvY1NsaWRlciIsIl91cGRhdGVXaXRoRG9jU2xpZGVyIiwiX3NlYXJjaEVsZW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/scrollcue/index.js\n"));

/***/ })

}]);